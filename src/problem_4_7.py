import pandas as pd
import numpy as np
import gurobipy as gb
from gurobipy import MVar

data = pd.read_csv('nodes3.csv')

generator_list = [10, 18, 27, 30]

# To change data, make sure to mach the order of the generator_list
init_capacity = np.array([417, 875, 914, 637])

# first row is the option for first generator in generator 1 ... etc.
add_capacity = np.array([[84, 209, 419],
                         [182, 448, 877],
                         [178, 449, 910],
                         [134, 319, 639]])

# match the order of the generator_list by rows
upgrade_cost = np.array([[8422000, 19585000, 39451000],
                         [17581000, 40246000, 80333000],
                         [17790000, 43071000, 82744000],
                         [12975000, 30564000, 58881000]])

# Define the number of options and the number of supplier nodes
num_options = add_capacity.shape[1]
G_num = len(generator_list)
# Create a mapping of generator indices
generator_map = {i: j for j, i in enumerate(generator_list)}
generator_set = set(generator_list)

# Read data from CSV files
raw_piplines = pd.read_csv("pipelines.csv")
nodes = data.to_numpy()
piplines = raw_piplines.to_numpy()

# Define column indices for nodes and pipelines
Node1, Node2, Demand_5, Demand_10 = 1, 2, 3, 4
E, N = len(piplines), len(nodes)

# Compute distances between nodes and create E array
START_NODES = piplines[:, 1].astype(int)
END_NODES = piplines[:, 2].astype(int)
START_NODES_XY = nodes[START_NODES, 1:3]
END_NODES_XY = nodes[END_NODES, 1:3]
distances = np.linalg.norm(START_NODES_XY - END_NODES_XY, axis=1)
distances = distances.reshape(-1)

# Create Gurobi model and variables
m = gb.Model()
# The amount of gas that flows through each pipeline in first 5 years
X1: MVar = m.addMVar((E,))
# The amount of gas that flows through each pipeline in second 5 years
X20: MVar = m.addMVar((E,))
X21: MVar = m.addMVar((E,))
X22: MVar = m.addMVar((E,))
# The amount the gas generated by each generator in first 5 years
Y1: MVar = m.addMVar((G_num,))
# The amount the gas generated by each generator in second 5 years
Y20: MVar = m.addMVar((G_num,))
Y21: MVar = m.addMVar((G_num,))
Y22: MVar = m.addMVar((G_num,))
# A binary matrix indicating whether each generator is upgraded or not
b1: MVar = m.addMVar((G_num, num_options), vtype=gb.GRB.BINARY)
b20: MVar = m.addMVar((G_num, num_options), vtype=gb.GRB.BINARY)
b21: MVar = m.addMVar((G_num, num_options), vtype=gb.GRB.BINARY)
b22: MVar = m.addMVar((G_num, num_options), vtype=gb.GRB.BINARY)
# A binary vector indicating whether each pipeline is upgraded or not
p1: MVar = m.addMVar((E,), vtype=gb.GRB.BINARY)
p20: MVar = m.addMVar((E,), vtype=gb.GRB.BINARY)
p21: MVar = m.addMVar((E,), vtype=gb.GRB.BINARY)
p22: MVar = m.addMVar((E,), vtype=gb.GRB.BINARY)

# Define demand, capacity, and cost arrays
demand1 = nodes[:, Demand_5]
demand2 = nodes[:, Demand_10]


nodes_set = {i for i in range(N)}
non_generator_set = nodes_set - generator_set
generator_map_inv = {i: j for j, i in generator_map.items()}

# Set objective function
m.setObjective((b1 * upgrade_cost).sum() + (p1 * distances * 200000).sum()
               + 1 / 3 * ((b20 * upgrade_cost).sum() + (p20 * distances * 200000).sum())
               + 1 / 3 * ((b21 * upgrade_cost).sum() + (p21 * distances * 200000).sum())
               + 1 / 3 * ((b22 * upgrade_cost).sum() + (p22 * distances * 200000).sum()),
               gb.GRB.MINIMIZE)

# constraints on edges
for i in range(E):
    m.addConstr(X1[i] <= (p1[i] + 1) * 280)
    m.addConstr(X20[i] <= (p20[i] + 1) * 280)
    m.addConstr(X21[i] <= (p21[i] + 1) * 280)
    m.addConstr(X22[i] <= (p22[i] + 1) * 280)
    m.addConstr(p1[i] + p20[i] <= 1)
    m.addConstr(p1[i] + p21[i] <= 1)
    m.addConstr(p1[i] + p22[i] <= 1)

# constraints on generators capacity and max choice on upgrade
for i in range(G_num):
    m.addConstr(Y1[i] <= (b1[i, :] * add_capacity[i, :]).sum() + init_capacity[i])
    m.addConstr(
        Y20[i] <= (b20[i, :] * add_capacity[i, :]).sum() + (b1[i, :] * add_capacity[i, :]).sum() + init_capacity[i])
    m.addConstr(b1[i, :].sum() + b20[i, :].sum() <= 1)
    m.addConstr(
        Y21[i] <= (b21[i, :] * add_capacity[i, :]).sum() + (b1[i, :] * add_capacity[i, :]).sum() + init_capacity[i])
    m.addConstr(b1[i, :].sum() + b21[i, :].sum() <= 1)
    m.addConstr(
        Y22[i] <= (b22[i, :] * add_capacity[i, :]).sum() + (b1[i, :] * add_capacity[i, :]).sum() + init_capacity[i])
    m.addConstr(b1[i, :].sum() + b22[i, :].sum() <= 1)

for i in generator_set:
    # Add flow balance constraints
    m.addConstr(
        Y1[generator_map[i]] + X1[END_NODES == i].sum()
        ==
        X1[START_NODES == i].sum() + demand1[i]
    )
    m.addConstr(
        Y20[generator_map[i]] + X20[END_NODES == i].sum()
        ==
        X20[START_NODES == i].sum() + 0.8 * demand2[i]
    )
    m.addConstr(
        Y21[generator_map[i]] + X21[END_NODES == i].sum()
        ==
        X21[START_NODES == i].sum() + demand2[i]
    )
    m.addConstr(
        Y22[generator_map[i]] + X22[END_NODES == i].sum()
        ==
        X22[START_NODES == i].sum() + 1.2 * demand2[i]
    )

for i in non_generator_set:
    # Add flow balance constraints
    m.addConstr(
        X1[END_NODES == i].sum() == X1[START_NODES == i].sum() + demand1[i]
    )
    m.addConstr(
        X20[END_NODES == i].sum() == X20[START_NODES == i].sum() + 0.8 * demand2[i]
    )
    m.addConstr(
        X21[END_NODES == i].sum() == X21[START_NODES == i].sum() + demand2[i]
    )
    m.addConstr(
        X22[END_NODES == i].sum() == X22[START_NODES == i].sum() + 1.2 * demand2[i]
    )

#
# Optimize the model
m.optimize()

# print solution
print("supplier upgrade option:")
print(b1.X)
print(b20.X)
print(b21.X)
print(b22.X)
print("pipline index to upgrade:")
print(np.where(p1.X == 1)[0])
print(np.where(p20.X == 1)[0])
print(np.where(p21.X == 1)[0])
print(np.where(p22.X == 1)[0])

# print upgrade cost
print("\n=============================================\n")
print("Total cost=", m.objval)
